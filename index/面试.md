[高级前端开发者必会的34道Vue面试题系列（一）](https://juejin.im/post/5e7410ed51882549087dc365)
[30 道 Vue 面试题，内含详细讲解](https://juejin.im/post/5d59f2a451882549be53b170)
[一年半经验，百度、有赞、阿里面试总结](https://github.com/yacan8/blog/blob/master/posts/%E4%B8%80%E5%B9%B4%E5%8D%8A%E7%BB%8F%E9%AA%8C%EF%BC%8C%E7%99%BE%E5%BA%A6%E3%80%81%E6%9C%89%E8%B5%9E%E3%80%81%E9%98%BF%E9%87%8C%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.md)
[张云龙 BLOG](https://github.com/fouber/blog)
[面试题](https://juejin.im/post/5c89b19fe51d45319629382c)
[2019 面试准备 - JS 防抖与节流](https://juejin.im/post/5c87b54ce51d455f7943dddb)
[页面生命周期——DOMContentLoaded&Loaded](https://juejin.im/post/59e49851f265da430b7a4bb8#heading-0)
[手写代码不是背出来的](https://juejin.im/post/5e57048b6fb9a07cc845a9ef)

---
宁波数联软件：数据可视化、外包、云服务
前端技术：徐XX
## 1. CSS 选择器优先级
 `!important > 行内样式 > ID > 类、伪类、属性 > 标签名 > 继承 > 通配符`
1. 选择器越具体，优先级越高。
2. 相同优先级情况下，后面的样式覆盖前面的。
3. !important 最特殊，有他的声明最优先，但应该避免使用。

看文档 [优先级](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity)

## 2. CSS 预处理
[再谈 CSS 预处理器](http://efe.baidu.com/blog/revisiting-css-preprocessors/)
CSS 预处理器是什么？一般来说，它们基于 CSS 扩展了一套属于自己的 DSL，来解决我们书写 CSS 时难以解决的问题：

语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；
没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。
所以这就决定了 CSS 预处理器的主要目标：提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。这不是锦上添花，而恰恰是雪中送炭。

## 3. 闭包
## 4. 介绍一下项目
## 5. vuex
## 6. 如何获取电脑IP
## 7. 其他语言
## 8. 事件委托
什么时候使用事件委托，当我们发送请求从后台获取数据替换原数据时，子元素可能被替换了（即生成的子元素为新生成的），此时可以使用事件委托监听父元素

---
宁波：幕枫网络：外包
面试题：基础知识，部分摘录
## 1. 垂直居中方法
### [七种方式实现垂直居中](https://jscode.me/t/topic/1936)

## 2. display: none 和 visibility: hidden 区别
### [前端面试题-display:none和visibility:hidden的区别](https://segmentfault.com/a/1190000013929168)
## 3. 清除浮动的方法，哪种好
### [清除浮动](https://segmentfault.com/a/1190000010160251)
## 4. call() 和 apply() 区别
call() 方法的作用和 apply() 方法类似，区别就是 call() 方法接受的是**参数列表**，而 apply() 方法接受的是**一个参数数组**。

## 5. 入栈出栈
考虑出栈是随机的，也就是在入栈还没结束的情况下就可以出栈

---
宁波：智加科技
## 1. 简单介绍一下项目
## 2. HTML5 CSS3 新属性
[HTML5
](https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5)
## 3. 闭包，有什么缺点
[闭包](https://zhuanlan.zhihu.com/p/22486908)
## 4. 内存
## 5. 数组去重
[JavaScript专题之数组去重](https://juejin.im/post/5949d85f61ff4b006c0de98b)
## 6. vue 生命周期
[详解vue生命周期](https://segmentfault.com/a/1190000011381906)
## 7. 响应式原理
主要提到了 [Object.defineProperty()
](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 
讲了 proxy 代理相关
## 8. react 了解多少
---
杭州：勤淮网络

1. Vue 了解多少？vuex？响应式原理？虚拟DOM？路由原理？ 为什么 hitsory 刷新后页面 404
2. ES6 了解多少？ Fetch 了解吗？
3. axios 如何获取 cookie？
[http://www.ruanyifeng.com/blog/2016/04/cors.html](http://www.ruanyifeng.com/blog/2016/04/cors.html)
4. Dom 事件了解吗？如何使用 js 判断 A 是 B （A 嵌套 B）的父元素？
5. setTimeout 参数？时间可否为 0 
6. 数组常用方法？ push、pop 等返回值是什么？
7. Flex 了解吗？
8. position 了解吗？
### static
该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。
### relative
该关键字下，元素先放置在**未添加定位时的位置**，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-group, table-row, table-column, table-cell, table-caption 元素无效。
### absolute
不为元素预留空间，通过指定元素**相对于最近的非 static 定位祖先元素**的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。
### fixed
不为元素预留空间，而是通过指定元素**相对于屏幕视口（viewport）**的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform  属性非 none 时，容器由视口改为该祖先。
### sticky 
盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。

9. 选择器优先级？
10. React 了解多少？
---
杭州：云霁科技
1. 介绍项目，讲讲印象深的
2. 闭包
3. Vue 生命周期？组件间通讯？
4. ES6 了解多少？Promise 怎么用？
5. 这段代码打印什么？如何改正确（考察 this，原生 js）
6. 数组去重？
[5分钟彻底理解Object.keys](https://juejin.im/post/5b593e065188251aff2169f7)
7. HTTP状态码？请求有哪几个部分？
8. CSS link 和 @import 区别？
## 区别
### 1.从属关系区别
@import是 CSS 提供的语法规则，只有导入样式表的作用；
```
<style type="text/css">
  @import url("XXX.css");
</style>
```
link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。
```
<link rel="stylesheet" href="YYY.css">
```
### 2.加载顺序区别
加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。
### 3.兼容性区别
@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。
### 4.DOM可控性区别
可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。
### 5.权重区别
事实证明没有区别，符合 CSS 优先级

[你真的理解@import和link引入样式的区别吗 ](https://juejin.im/post/5ab36d99f265da23866fccd1)

---
方方
# 1. 微信小程序相关面试题
[微信小程序必知面试题](https://www.jianshu.com/p/7821aab256a8)
## 1.1 小程序请求封装
### 为什么进行封装
- 针对性得设置请求的主域名、请求头等默认值，减少请求使用参数和其他配置等
- 可以统一处理一些逻辑，如针对请求异常的提醒机制等
- 可以对请求进行改造来满足使用习惯
### 如何封装
1. 使用 promise 作请求的异步处理
2. 使用 async/await 并配合 try/catch
## 1.2 小程序的大小限制
小程序一开始时代码包限制为 1MB，但我们收到了很多反馈说代码包大小不够用，经过评估后我们放开了这个限制，增加到 **2MB** 。
# 2. 数据可视化相关
## echarts.js    d3.js
# Vue 相关
## vue.set
### [Vue.set( target, key, value )](https://cn.vuejs.org/v2/api/#Vue-set "Vue.set( target, key, value )")
vue 的响应式原理是通过 Object.defineProperty 的 getter 获取 vue 实例的 data 选项的所以属性，通过调用 setter 通知对应的 watcher 来重新计算，从而更新组件内容。
因此在初始化实例后，Vue 不能检测到 data 对象属性的添加或删除，若需要添加或删除对象的响应式属性，需要用 Vue.set(object, key, value) 方法
```
Vue.set(vm.someObject, 'b', 2)
// 全局 Vue.set 方法的别名: vm.$set 实例方法
this.$set(this.someObject,'b',2)
```
## computed & watch & methods 区别
computed 是计算属性，用于处理模版表达式需要大量计算的时候。
计算属性默认只有 getter 函数是没有副作用的
计算属性可以设置 setter，用于更新依赖
```
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
```
computed  与 methods 方法相比是其有缓存（**计算属性是基于它们的依赖进行缓存的**），在对**需要缓存的数据做处理时推荐使用 computed**；
```
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>
```
message 就是 reversedMessage 的依赖，且当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新
```
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```

此外 methods 作模版语法时需要在表达式中调用
```
// computed 方法
<p>Computed reversed message: "{{ reversedMessage }}"</p>
// methods 方法，需要调用函数（加括号）
<p>Reversed message: "{{ reversedMessage() }}"</p>
```
且每当触发重新渲染时，调用方法将**总会**再次执行函数；

watch 是侦听属性（**用于观察和响应 Vue 实例上的数据变动**），watch 也是有缓存的，但我们不该滥用 watch，计算属性的声明式 getter 方法能够又好又快得解决 watch 对数据需要随着其它数据变动而变动时使用到的繁琐命令式方法。
```
<div id="demo">{{ fullName }}</div>
```
```
// watch：是命令式且重复的
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})
// computed：声明式、简洁明了
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```
而当**需要在数据变化时执行异步或开销较大的操作时使用 watch**。

# axios
## 实现增删改查
### 发起 GET 请求：查
![](https://upload-images.jianshu.io/upload_images/7094266-12145e74b1272089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
const axios = require('axios') // 下同省略

//发起一个user请求，参数为给定的ID
axios.get('/user?ID=12345')
  .then((response) => {
    console.log(response)
  }
  .catch((error) => {
    console.log(error)
  }
```
### 发起 POST 请求：增
![](https://upload-images.jianshu.io/upload_images/7094266-8609f819ec24a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
axios.post('/user', {
  firstName: 'yuanda',
  lastName: 'zhou'
})
  .then((response) => {
    console.log(response)
  })
  .catch(function(error){
    console.log(error);
  })
```
```
axios.request(config)
axios.get(url[,config])
axios.delete(url[,config]) // 删除
axios.head(url[,config])
axios.options(url[,config])
axios.post(url[,data[,config]])
axios.put(url[,data[,config]]) // 改
axios.patch(url[,data[,config]])
```
PUT 和 POST 方法的区别是,PUT方法是幂等的：连续调用一次或者多次的效果相同（无副作用）。连续调用同一个POST可能会带来额外的影响，比如多次提交订单。
## 并发请求
```
function getUserAccount(){
    return axios.get('/user/12345');
}

function getUserPermissions(){
    return axios.get('/user/12345/permissions');
}

axios.all([getUerAccount(),getUserPermissions()])
    .then(axios.spread(function(acc,pers){
        //两个请求现在都完成
    }));
```
axios.all 使用的是类似 Primise.all 的功能，所以如果其中有一个请求出现了错误那么就会停止请求，所以建议对于单个请求最好附加上处理的 catch。
## 拦截器 interceptors
你可以在**请求**或者**响应**被 then 或者 catch 处理之前对他们进行拦截。
```
//添加一个请求拦截器
axios.interceptors.request.use(function(config){
    //在请求发送之前做一些事
    return config;
},function(error){
    //当出现请求错误是做一些事
    return Promise.reject(error);
});

//添加一个返回拦截器
axios.interceptors.response.use(function(response){
    //对返回的数据进行一些处理
    return response;
},function(error){
    //对返回的错误进行一些处理
    return Promise.reject(error);
});
```
用 eject 移除拦截器
```
var myInterceptor = axios.interceptors.request.use(function(){/*...*/});
axios.interceptors.request.eject(myInterceptor);
```
---
## JWT 是什么？
[JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)
