作用域有两种模型：

1. 词法作用域（本章介绍）
2. 动态作用域：运行时被动态确定

### 2.1 词法阶段

词法作用域是定义在词法分析阶段的作用域。

三个逐级嵌套的作用域可以想象成三个逐级包含的气泡：

![image.png](https://upload-images.jianshu.io/upload_images/7094266-11f4137d797bf7a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**作用域气泡**由作用域代码块的位置决定，同时**是严格包含**的关系，**非**如下图 **文氏图** 的关系



![文氏图](https://upload-images.jianshu.io/upload_images/7094266-7012f4428347516f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###### 查找

引擎通过作用域气泡的结构和位置关系查找标识符位置

引擎查找是从运行时所处的最内部作用域开始，逐层向上的，在找到第一个标识符停止，同时会有“遮蔽效应（内部的标识符“遮蔽”了外部的标识符）”

间接地通过对全局对象属性引用如 window.a 可以访问被同名变量所遮蔽的全局变量

词法作用域都只由函数被声明时所处的位置决定，与调用无关

### 2.2 欺骗词法

在运行时“修改”词法作用域

欺骗词法作用域最重要的问题是会导致性能下降

有两种机制：

###### 2.2.1 eval

```javascript
function foo(str, a) {
	eval( str ); // 欺骗！
	console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```

eval 内部的字符串在运行时动态插入，这样就可能改变了原有声明时的词法作用域

在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其
中的声明无法修改所在的作用域

```javascript
function foo(str) {
	"use strict";
	eval( str );
	console.log( a ); // ReferenceError: a is not defined
}
foo( "var a = 2" );
```

类似 eval(..) 的还有 

1. setTimeout(..) 的第一个参数
2. setInterval(..) 的第一个参数
3. new Function(..) 函数的最后一个参数（前面的参数是这个新生成的函数的形参）

它们都可以是字符串，可被解释为动态生成的函数，会有性能和安全问题，需要避免使用

###### 2.2.2 with

with 通常被当作重复引用同一个对象中的多个属性的快捷方式：

```javascript
var obj = {
	a: 1,
	b: 2,
	c: 3
};
// 单调乏味的重复 "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
	a = 3;
	b = 4;
	c = 5;
}
```

问题：

```javascript
function foo(obj) {
	with (obj) {
		a = 2;
	}
}
var o1 = {
	a: 3
};
var o2 = {
	b: 3
};
foo( o1 );
console.log( o1.a ); // 2
foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```

执行 console.log( o2.a ) 时会执行 LHS 标识符查找，由于找不到会创建全局变量（非严格模式），然后 a = 2 执行就挂到全局了

###### 2.2.3 性能

JavaScript 引擎会在**编译阶段**进行数项的**性能优化**，其中有些优化**依赖**于对词法进行**静态分析**，并**预先确定**所有变量和函数的定义位置，从而在执行过程中快速找到标识符

eval(..) 和 with 会在**运行时修改或创建新的作用域**，以此来欺骗其他在书写时定义的词法作用域，因此编译阶段进行的性能优化在它们出现时变得**无法预料和毫无意义，造成性能问题**

### 2.3 小结

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的

引擎通过编译的词法分析阶段判断标识符声明的位置和方式，从而在行过程中快速查找

JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with

前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）

后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认
为这样的优化是无效的