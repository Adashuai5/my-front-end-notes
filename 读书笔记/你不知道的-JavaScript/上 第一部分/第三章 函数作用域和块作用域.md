

本章探究 JS 中能够产生作用域“气泡”的结构

### 3.1 函数中的作用域

函数作用域：属于这个函数的全部变量都可以在整个函数（包括嵌套的作用域中）的范围内使用及复用

该设计方案能充分发挥 JavaScript 的**“动态”变量**特性

### 3.2 隐藏的内部实现

传统认知是先声明一个函数，然后向里面加代码；反过来可以理解为**用函数对代码中的片段进行“隐藏”**

符合**最小特权（暴露）原则**：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计

通过隐藏变量将内部实现私有化而非放在全局是良好的设计

###### 规避冲突

隐藏变量的另一个好处是避免标识符的命名冲突

1. 全局命名空间

第三方库通常会在全局作用域中声明一个名字足够独特的变量作为库的**命名空间**，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性

2. 模块管理

另外一种避免冲突的办法和现代的模块机制很接近，就是使用模块管理工具，通过依赖管理器
的机制将库的标识符显式地导入到另外一个特定的作用域中

### 3.3. 函数作用域

通过函数隐藏内部变量和函数的缺点：

```javascript
var a = 2;
function foo() { // <-- 添加这一行
 	var a = 3;
	console.log( a ); // 3
} // <-- 以及这一行
foo(); // <-- 以及这一行
console.log( a ); // 2
```



1. 用于包裹的具名函数 foo 本身“污染”了所在作用域
2. 必须显示通过函数名 foo() 调用才能运行其中代码

解决方法：

```javascript
var a = 2;
(function foo() { // <-- 添加这一行
 	var a = 3;
	console.log( a ); // 3
})() // <-- 以及这一行
foo(); // <-- 以及这一行
console.log( a ); // 2
```

通过 (function...) 的形式将函数声明变为函数表达式

> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位
> 置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中
> 的第一个词，那么就是一个函数声明，否则就是一个函数表达式

(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行

###### 3.3.1 匿名和具名

函数表达式作为回调参数的场景

```javascript
setTimeout( function() {
	console.log("I waited 1 second!");
}, 1000 );
```

函数表达式可以是匿名的（如上代码），而函数声明则不可以省略函数名

匿名函数表达式的缺点：

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得**调试很困难**
2. 在如递归或事件监听器解绑等需要**引用自身**的场景，只能使用 [arguments.callee(已作废)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments/callee) 引用
3. 匿名函数省略了对于**代码可读性 / 可理解性**很重要的函数名

因此**具名的函数表达式十分必要**

###### 立即执行函数表达式

(function foo(){ .. })()：第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数

> 几年前社区给它规定了一个术语：IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression）

### 块作用域

块作用域是对最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息

###### 3.4.1 with

with 是块作用域的一种形式

###### 3.4.2 try/catch

ES3 规范中规定 try/catch 的 **catch 分句会创建一个块作用域**，其中声明的变量仅在 catch 内部有效

```javascript
try {
 undefined(); // 执行一个非法操作来强制制造一个异常
}
catch (err) {
 console.log( err ); // 能够正常执行！
}
console.log( err ); // ReferenceError: err not found
```

附录B：

事实上在对 ES6 的 let 提供的块作用域进行兼容 ES6 之前的环境时，可以用到 catch 的这种性质

```javascript
{ 
	try {
		throw undefind
	} catch (a) {
		a = 2;
		console.log(2);
	}
}
```

###### 3.4.3 let

let 为其声明的变量**隐式**地劫持了所在的块作用域

不注意这点习惯性的移动块作用域的代码块会导致代码混乱

为块作用域显式地创建块可以部分解决这个问题

```javascript
var foo = true;
if (foo) {
	{ // <-- 显式的块
		let bar = foo * 2;
		bar = something( bar );
		console.log( bar );
	}
}
console.log( bar ); // ReferenceError
```

let 能够**避免**声明的**提升**



1. 垃圾收集

闭包及内存垃圾回收机制也与块作用域相关

为变量**显式声明块作用域**，**有利于** JavaScript 引擎识别出内存中占用的无用数据结构，进行**垃圾回收**

2. let 循环

```javascript
for (let i=0; i<10; i++) {
	console.log( i );
}
console.log( i ); // ReferenceError
```

事实上 let 将 i **重新绑定**到了循环的**每一个迭代**中

```javascript
{
	let j;
	for (j=0; j<10; j++) {
		let i = j; // 每个迭代重新绑定！
		console.log( i );
	}
}
```

###### 3.4.4 const

用于块作用域内声明常量

### 3.5 小结

1. 函数内部的变量或函数会在所处的作用域中“隐藏”起来
2. 除函数作用域外，块作用域可以让变量和函数属于某个代码块
3. ES3 的 try/catch 结构在 catch 分句中具有块作用域
4. ES6 中引入了 let 关键字，在任意代码块中声明变量

